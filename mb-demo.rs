//! Generated by ChatGPT so I will cry if this ends up working
extern crate bcm2711_sys;

use bcm2711_sys::mailbox;
use bcm2711_sys::vc_mbox_property_tags::*;

fn main() {
    // Allocate memory for the framebuffer.
    let mut fb: [u8; 800 * 480 * 4] = [0; 800 * 480 * 4];

    // Set the first pixel to red.
    fb[0] = 0xff;
    fb[1] = 0;
    fb[2] = 0;
    fb[3] = 0xff;

    // Set up the mailbox property tags.
    let mut tags = [MAILBOX_TAG_BLANK; 8];
    tags[0] = MAILBOX_TAG_SET_PHYSICAL_WIDTH_HEIGHT(800, 480);
    tags[1] = MAILBOX_TAG_SET_VIRTUAL_WIDTH_HEIGHT(800, 480);
    tags[2] = MAILBOX_TAG_SET_DEPTH(32);
    tags[3] = MAILBOX_TAG_ALLOCATE_BUFFER;
    tags[4] = MAILBOX_TAG_GET_PITCH;
    tags[5] = MAILBOX_TAG_SET_PIXEL_ORDER(1);  // RGB
    tags[6] = MAILBOX_TAG_SET_ALPHA_MODE(1);   // Enabled
    tags[7] = MAILBOX_TAG_LAST;

    // Send the property tags to the GPU.
    let mut buffer = [0; 32];
    let result = mailbox::mbox_property(&mut tags[0] as *mut u32, &mut buffer[0] as *mut u32);
    if result != 0 {
        panic!("Failed to send mailbox property tags");
    }

    // Get the framebuffer address and pitch from the response.
    let fb_addr = buffer[5] as *mut u8;
    let pitch = buffer[7];

    // Copy the framebuffer data to the GPU.
    for y in 0..480 {
        for x in 0..800 {
            let offset = (y * pitch + x * 4) as isize;
            unsafe {
                *fb_addr.offset(offset) = fb[(y * 800 + x) * 4];
                *fb_addr.offset(offset + 1) = fb[(y * 800 + x) * 4 + 1];
                *fb_addr.offset(offset + 2) = fb[(y * 800 + x) * 4 + 2];
                *fb_addr.offset(offset + 3) = fb[(y * 800 + x) * 4 + 3];
            }
        }
    }
}
